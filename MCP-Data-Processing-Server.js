/**
 * MCP Data Processing Server - CRITICAL for Semantic Joining
 * 
 * Purpose: Replaces the problematic "Merge - Outreach" node with semantic joining
 * Critical Function: Preserves all 27 job items while enriching with contact data
 * 
 * Generated by: Claude Sonnet 4
 * Date: 2025-09-12
 * Port: 3005
 */

const express = require('express');
const cors = require('cors');
const app = express();

// Middleware
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Data Processing MCP Server',
    port: 3005,
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

/**
 * CRITICAL ENDPOINT: Semantic Joining
 * Replaces the "Merge - Outreach" node that causes 85% data loss
 * 
 * Input: jobData (27 items), resumeData (27 items), contactData (4 items)
 * Output: enrichedData (27 items) - ZERO DATA LOSS
 */
app.post('/mcp/data/semantic-join', async (req, res) => {
  console.log('ðŸ”§ Processing semantic join request...');
  
  try {
    const { jobData, resumeData, contactData } = req.body.parameters;
    const options = req.body.options || {};
    
    // Validation
    if (!jobData || !Array.isArray(jobData)) {
      return res.status(400).json({
        success: false,
        error: 'jobData is required and must be an array'
      });
    }
    
    console.log(`ðŸ“Š Input data: ${jobData.length} jobs, ${resumeData?.length || 0} resumes, ${contactData?.length || 0} contacts`);
    
    const results = [];
    const processingStats = {
      totalJobs: jobData.length,
      jobsWithResumes: 0,
      jobsWithContacts: 0,
      jobsFullyEnriched: 0,
      processingStartTime: Date.now()
    };
    
    // Process ALL job items (CRITICAL: preserves all 27 items)
    for (const job of jobData) {
      const enrichedItem = {
        // Core job data (always preserved)
        jobId: job.jobId,
        companyName: job.companyName,
        jobTitle: job.jobTitle,
        jobUrl: job.jobUrl,
        companyWebsite: job.companyWebsite,
        companyDomain: job.companyDomain,
        dedupeKey: job.dedupeKey,
        matchScore: job.matchScore,
        qualificationStatus: job.qualificationStatus,
        timestamp: job.timestamp,
        
        // Resume data (semantic join by jobId)
        resumeUrl: null,
        resumeDocId: null,
        customizationApplied: false,
        
        // Contact data (semantic join by dedupeKey)
        contactEmail: null,
        contactFirstName: null,
        contactLastName: null,
        contactJobTitle: null,
        emailStatus: 'not_found',
        
        // Processing metadata
        processingTimestamp: new Date().toISOString(),
        enrichmentLevel: 'job_only'
      };
      
      // Enrich with resume data (semantic join by jobId)
      if (resumeData && Array.isArray(resumeData)) {
        const resume = resumeData.find(r => r.jobId === job.jobId);
        if (resume) {
          enrichedItem.resumeUrl = resume.resumeUrl;
          enrichedItem.resumeDocId = resume.resumeDocId;
          enrichedItem.customizationApplied = resume.customizationApplied || false;
          enrichedItem.enrichmentLevel = 'job_resume';
          processingStats.jobsWithResumes++;
        }
      }
      
      // Enrich with contact data (semantic join by dedupeKey)
      if (contactData && Array.isArray(contactData)) {
        // Normalize dedupeKey for matching (handle case variations)
        const normalizedJobKey = job.dedupeKey?.toLowerCase().trim();
        
        const contact = contactData.find(c => {
          const normalizedContactKey = c.dedupeKey?.toLowerCase().trim();
          return normalizedContactKey === normalizedJobKey;
        });
        
        if (contact) {
          enrichedItem.contactEmail = contact.email;
          enrichedItem.contactFirstName = contact.firstName;
          enrichedItem.contactLastName = contact.lastName;
          enrichedItem.contactJobTitle = contact.jobTitle;
          enrichedItem.emailStatus = contact.emailStatus || 'found';
          enrichedItem.enrichmentLevel = enrichedItem.enrichmentLevel === 'job_resume' ? 'fully_enriched' : 'job_contact';
          processingStats.jobsWithContacts++;
          
          if (enrichedItem.enrichmentLevel === 'fully_enriched') {
            processingStats.jobsFullyEnriched++;
          }
        }
      }
      
      // CRITICAL: Add ALL items regardless of enrichment status
      // This prevents the data loss that occurred in the "Merge - Outreach" node
      results.push(enrichedItem);
    }
    
    processingStats.processingEndTime = Date.now();
    processingStats.processingDuration = processingStats.processingEndTime - processingStats.processingStartTime;
    
    // Generate comprehensive response
    const response = {
      success: true,
      data: results,
      metadata: {
        itemsProcessed: results.length,
        itemsEnriched: processingStats.jobsWithContacts,
        itemsWithResumes: processingStats.jobsWithResumes,
        itemsFullyEnriched: processingStats.jobsFullyEnriched,
        dataLossPercentage: 0, // CRITICAL: Always 0% vs 85% in old system
        processingTime: `${processingStats.processingDuration}ms`,
        enrichmentStats: {
          jobOnly: results.filter(r => r.enrichmentLevel === 'job_only').length,
          jobResume: results.filter(r => r.enrichmentLevel === 'job_resume').length,
          jobContact: results.filter(r => r.enrichmentLevel === 'job_contact').length,
          fullyEnriched: results.filter(r => r.enrichmentLevel === 'fully_enriched').length
        }
      }
    };
    
    console.log(`âœ… Semantic join completed: ${results.length} items processed (0% data loss)`);
    console.log(`ðŸ“Š Enrichment: ${processingStats.jobsWithContacts} contacts, ${processingStats.jobsWithResumes} resumes`);
    
    res.json(response);
    
  } catch (error) {
    console.error('âŒ Semantic join error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

/**
 * DedupeKey Generation Endpoint
 * Generates standardized dedupeKey for consistent matching
 */
app.post('/mcp/data/generate-dedupekey', async (req, res) => {
  try {
    const { companyName, jobTitle } = req.body.parameters;
    
    if (!companyName || !jobTitle) {
      return res.status(400).json({
        success: false,
        error: 'companyName and jobTitle are required'
      });
    }
    
    // Normalize and generate dedupeKey
    const normalizedCompany = companyName.toLowerCase().trim()
      .replace(/[^\w\s]/g, '') // Remove special characters
      .replace(/\s+/g, ' '); // Normalize whitespace
    
    const normalizedTitle = jobTitle.toLowerCase().trim()
      .replace(/[^\w\s]/g, '') // Remove special characters
      .replace(/\s+/g, ' '); // Normalize whitespace
    
    const dedupeKey = `${normalizedCompany}|${normalizedTitle}`;
    
    res.json({
      success: true,
      data: {
        dedupeKey: dedupeKey,
        companyName: normalizedCompany,
        jobTitle: normalizedTitle
      }
    });
    
  } catch (error) {
    console.error('âŒ DedupeKey generation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Data Validation Endpoint
 * Validates data structure and completeness
 */
app.post('/mcp/data/validate', async (req, res) => {
  try {
    const { data, schema } = req.body.parameters;
    
    if (!data || !Array.isArray(data)) {
      return res.status(400).json({
        success: false,
        error: 'data is required and must be an array'
      });
    }
    
    const validationResults = {
      totalItems: data.length,
      validItems: 0,
      invalidItems: 0,
      missingFields: [],
      errors: []
    };
    
    const requiredFields = schema?.requiredFields || ['jobId', 'companyName', 'jobTitle', 'dedupeKey'];
    
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      let isValid = true;
      
      for (const field of requiredFields) {
        if (!item[field] || item[field] === '') {
          validationResults.missingFields.push(`Item ${i}: missing ${field}`);
          isValid = false;
        }
      }
      
      if (isValid) {
        validationResults.validItems++;
      } else {
        validationResults.invalidItems++;
      }
    }
    
    const validationPassed = validationResults.invalidItems === 0;
    
    res.json({
      success: validationPassed,
      data: validationResults,
      message: validationPassed ? 'All items valid' : `${validationResults.invalidItems} items failed validation`
    });
    
  } catch (error) {
    console.error('âŒ Data validation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Data Transformation Endpoint
 * Transforms data between different formats
 */
app.post('/mcp/data/transform', async (req, res) => {
  try {
    const { data, transformationType } = req.body.parameters;
    
    if (!data || !Array.isArray(data)) {
      return res.status(400).json({
        success: false,
        error: 'data is required and must be an array'
      });
    }
    
    let transformedData = [];
    
    switch (transformationType) {
      case 'normalize_keys':
        transformedData = data.map(item => {
          const normalized = {};
          for (const [key, value] of Object.entries(item)) {
            const normalizedKey = key.toLowerCase().replace(/[^a-z0-9]/g, '_');
            normalized[normalizedKey] = value;
          }
          return normalized;
        });
        break;
        
      case 'add_timestamps':
        transformedData = data.map(item => ({
          ...item,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }));
        break;
        
      case 'flatten_nested':
        transformedData = data.map(item => {
          const flattened = {};
          const flatten = (obj, prefix = '') => {
            for (const [key, value] of Object.entries(obj)) {
              const newKey = prefix ? `${prefix}_${key}` : key;
              if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                flatten(value, newKey);
              } else {
                flattened[newKey] = value;
              }
            }
          };
          flatten(item);
          return flattened;
        });
        break;
        
      default:
        return res.status(400).json({
          success: false,
          error: `Unknown transformation type: ${transformationType}`
        });
    }
    
    res.json({
      success: true,
      data: transformedData,
      metadata: {
        originalCount: data.length,
        transformedCount: transformedData.length,
        transformationType: transformationType
      }
    });
    
  } catch (error) {
    console.error('âŒ Data transformation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('âŒ Server error:', error);
  res.status(500).json({
    success: false,
    error: 'Internal server error',
    timestamp: new Date().toISOString()
  });
});

// Start server
const PORT = 3005;
app.listen(PORT, () => {
  console.log(`ðŸš€ Data Processing MCP Server running on port ${PORT}`);
  console.log(`ðŸ”§ Critical Function: Semantic joining to replace "Merge - Outreach" node`);
  console.log(`âœ… Zero data loss guaranteed: All 27 job items will be preserved`);
  console.log(`ðŸ“Š Health check: http://localhost:${PORT}/health`);
});

module.exports = app;
